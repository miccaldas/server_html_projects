<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>I Have a Problem Part2</title><link rel="stylesheet" href="/css/normalize.css"><link rel="stylesheet" href="/css/heti.min.css"><link rel="stylesheet" href="/css/hexo-theme-adoubi.css"><link rel="icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
</head><body><div class="header"><a class="github-link" target="_blank" rel="noopener" href="https://notabug.org/micaldas"><img class="github-image" src="/images/Aquicon-Github-small.png"></a><a class="email-link" href="mailto:mclds@protonmail.com"><img class="email-image" src="/images/email-small.png"></a><a class="subscribe-link" href="/atom.xml"><img class="subscribe-image" src="/images/subscribe-small.png"></a></div><div class="content"><div class="post-item"></div><h2 class="post-title-wrapper"><p class="post-title">I Have a Problem Part2</p></h2><div class="post-date"><time datetime="2021-01-30T23:08:08.000Z">2021-01-30</time></div><div class="post-content"><p>New news on the database and table automation front. None of them good. After a strong beginning, as told in the update to the first part of this series,<br>I reached another deadlock, two actually:  </p>
<ol>
<li>How to unpack dictionary items to free standing variables,  </li>
<li>How to automate the string manipulations necessary for transforming the received input into a SQL query that SQLite accepts.  </li>
</ol>
<p>In regards to the collecting the information from the user, I have the following set-up:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect_data</span>():</span>  </span><br><span class="line">    db_name = <span class="built_in">input</span>(color(<span class="string">&#x27;What name do you want for the database? &#x27;</span>, fore=<span class="string">&#x27;#585a47&#x27;</span>))</span><br><span class="line">    table_name = <span class="built_in">input</span>(color(<span class="string">&#x27;What name do you want for the table? &#x27;</span>, fore=<span class="string">&#x27;#585a47&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    a = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    col_num = <span class="built_in">int</span>(<span class="built_in">input</span>(color(<span class="string">&#x27;How many columns will you need? &#x27;</span>, fore=<span class="string">&#x27;#ff6f69&#x27;</span>)))</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(col_num):</span><br><span class="line">        col_name = <span class="built_in">input</span>(color(<span class="string">&#x27;What is the name of your column? &#x27;</span>, fore=<span class="string">&#x27;#ff6f69&#x27;</span>))</span><br><span class="line">        key = col_name</span><br><span class="line">        a.setdefault(key, [])</span><br><span class="line">        att_num = <span class="built_in">int</span>(<span class="built_in">input</span>(color(<span class="string">&#x27;How many attributes will you need? &#x27;</span>, fore=<span class="string">&#x27;#ff6f69&#x27;</span>)))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(att_num):</span><br><span class="line">            att_name = <span class="built_in">input</span>(color(<span class="string">&#x27;What is the name of your attribute? &#x27;</span>, fore=<span class="string">&#x27;#ff6f69&#x27;</span>))</span><br><span class="line">            a[key].append(att_name)</span><br></pre></td></tr></table></figure>
<p>As you can see, in order to steer clear of the long, repetitive lists from my first attempt, I managed to encapsulate all needed questions and answers in the<br>very compact set of lines. And that pleases me to no end. But what I didn’t considered this time, is that by using loops, I can’t isolate in variables, each iteration of the loop. I can access them as data points inside a dictionary; but that doesn’t give me the freedom that I need to manipulate the answers strings to serve<br> SQL query.<br> At the same time, I ask myself if I’m wrong about this. That the dictionaries methods are enough for me to pass all necessary information to the query. But if it is, I haven’t been smart enough to figure it it out.<br> The thing is this: The output I currently get, explaining what columns to use and what attributes they’ll have, has the following aspect.<br> This is for a test table which would have the following structure:  </p>
<ol>
<li>Column Name: ‘ID’       Column Attributes: INT, NOT NULL, PRIMARY KEY,  </li>
<li>Column Name: ‘Title’    Column Attributes: TEXT,  </li>
<li>Column Name: ‘Link’     Column Attributes: TEXT  </li>
</ol>
<p> For it to become an acceptable query, it will have to have this format:  </p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>( id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY, title TEXT, link TEXT)</span><br></pre></td></tr></table></figure>
<p>And this is how I’m getting the information from the questions processing function:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(<span class="string">&#x27;id&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;not null&#x27;</span>, <span class="string">&#x27;primary key&#x27;</span>]), (<span class="string">&#x27;title&#x27;</span>, [<span class="string">&#x27;text&#x27;</span>]), (<span class="string">&#x27;link&#x27;</span>, [<span class="string">&#x27;text&#x27;</span>])])</span><br></pre></td></tr></table></figure>

<p>A few things about this; the ‘OrderedDict’ is a string that comes from creating this dictionary as an <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">ordered dictionary</a>, a type of dictionary that has some item manipulations methods that seemed interesting to me. For one the order in what the items were inputted is remembered, and it doesn’t change from one invocation to another, as it happens in the other dictionaries.<br>So, for the sake of argument, let’s imagine that I’m right, (oh, in what shaky foundations we build this reasoning!), and that there is the need to free the information from its dictionary prison. In that case we have to embark in a series of alterations to this output, for it to be accepted by SQLite.<br>My first problem is all the punctuation that has to go. At this moment, If I ask how many elements are in that string, the answer is 3:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> [(<span class="string">&#x27;id&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;not null&#x27;</span>, <span class="string">&#x27;primary key&#x27;</span>]),</span><br><span class="line"><span class="number">2.</span> (<span class="string">&#x27;title&#x27;</span>, [<span class="string">&#x27;text&#x27;</span>]),</span><br><span class="line"><span class="number">3.</span> (<span class="string">&#x27;link&#x27;</span>, [<span class="string">&#x27;text&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>So I need to eliminate all the python syntax symbols.<br>To do that, I did the following operations:  </p>
<ol>
<li>Transform the output into a list. In order to be able to access elements individually, is necessary to turn the items from the dictionary into a list. So we create a list called ‘items’, with all it’s content. ‘Item’ refers to a key:value pair.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items = <span class="built_in">list</span>(a.items())  </span><br></pre></td></tr></table></figure></li>
<li>Create a empty list to house the transformed values we will create.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = []</span><br></pre></td></tr></table></figure></li>
<li>Create a loop where we’ll iterate through the items and subject them to several manipulations:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br></pre></td></tr></table></figure></li>
<li>Create a new variable to house the transformation from a list into a string. The new variable is needed for reasons of clarity and it will be necessary when doing the string manipulations, as strings are immutable, each alteration creates a new string. The reason to turn it to a string is because all the methods that I know of changing characters, are string methods. If I’m wrong, please tell me, as this is not the most comfortable of environments.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ita = <span class="built_in">str</span>(i)</span><br></pre></td></tr></table></figure></li>
<li>Now we clean the output of the “()[]’” characters.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itb = ita.translate(&#123;<span class="built_in">ord</span>(i): <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;()[]&#x27;&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>We separate the items in different units, using the commas as measurements where to cut.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itc = itb.split(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>We cleave the first element of this separated string and keep it in a list. It is the first columns name. Now that I’m looking back at this, I think that this<br>step is superfluous, but I’ll leave it, to document what I’ve done. Warts and all.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itd = itc[<span class="number">0</span>]</span><br><span class="line">results.append(itd)</span><br></pre></td></tr></table></figure></li>
<li>Now we separate the rest of the column specifications (its attributes), in another variable.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ite = itc[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure></li>
<li>And we turn it into a string.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itf = <span class="built_in">str</span>(ite)</span><br></pre></td></tr></table></figure></li>
<li>Now we clean this output of the characters, “[],’”.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itg = itf.translate(&#123;<span class="built_in">ord</span>(i): <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;[],&#x27;&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>And turn their characters into uppercase. It’s not really needed but, it’s a SQL convention that I honor because it makes the output more legible. Then we append it<br>to the list.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ith = itg.upper()</span><br><span class="line">results.append(ith)</span><br></pre></td></tr></table></figure></li>
<li>Now for the creation of the query. We start with the beginning of the query in a string. The rest will be added when we insert the values.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query1 = <span class="string">&#x27;CREATE TABLE &#x27;</span> + table_name + <span class="string">&#x27;(&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>Now we iterate through the list were we saved our variables, and add them some punctuation needed to build the query. And we’re done.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    query1 += result + <span class="string">&#x27; &#x27;</span></span><br><span class="line">query2 = query1 + <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>
The resulting output is this:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cards(id  <span class="type">INT</span>  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">PRIMARY</span> KEY title  TEXT link  TEXT )</span><br></pre></td></tr></table></figure></li>
</ol>
<p>And I observe that, after all this, we still have configuration problems.<br>The command lacks two commas that are fundamental. I know this because I tried to sent it as is (trusting that the Gods of SQL were with me), and it didn’t work.<br>What is needed is a comma after ‘PRIMARY KEY’, and another after the first ‘TEXT’. Like this.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cards(id  <span class="type">INT</span>  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">PRIMARY</span> KEY, title  TEXT, link  TEXT )</span><br></pre></td></tr></table></figure>
<p>And this is where I get into trouble.<br>Remember that we’re dealing with a string, so any attempt at indexing has to take into account that, the there is an index for each character and space in the query.<br>There are, now, no concepts like three elements, each indexed with its own tag.<br>Now, if we want to manipulate the string we’ll have to think character by character.<br>But that would be a wasted effort. The places were we want to put our commas will be in the different indexes every time a new table is built. There’s no way to guarantee that every time, at that location, will be the end of ‘PRIMARY KEY’, for example.<br>So I looked for methods that would delete characters by their recurrence or by type.<br>I tried this function I found in Stack Overflow:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_repl</span>(<span class="params">s, sub, repl, n</span>):</span></span><br><span class="line">   find = s.find(sub)</span><br><span class="line">   <span class="comment"># If find is not -1 we have found at least one match for the substring</span></span><br><span class="line">   i = find != -<span class="number">1</span></span><br><span class="line">   <span class="comment"># loop until we find the nth or we find no match</span></span><br><span class="line">   <span class="keyword">while</span> find != -<span class="number">1</span> <span class="keyword">and</span> i != n:</span><br><span class="line">       <span class="comment"># find + 1 means we start searching from after the last match</span></span><br><span class="line">       find = s.find(sub, find + <span class="number">1</span>)</span><br><span class="line">       i += <span class="number">1</span></span><br><span class="line">   <span class="comment"># If i is equal to n we found nth match so replace</span></span><br><span class="line">   <span class="keyword">if</span> i == n:</span><br><span class="line">       <span class="keyword">return</span> s[:find] + repl + s[find+<span class="built_in">len</span>(sub):]</span><br><span class="line">   <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">str</span>(results)</span><br><span class="line">s1 = nth_repl(s, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">1</span>) <span class="comment"># Replaces 1st occurrence of a comma</span></span><br><span class="line">s2 = nth_repl(s1, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">s3 = nth_repl(s2, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>It didn’t work. Don’t know why. It should have worked. But the fucking commas were still there, after each attempt I did.<br>I tried to get there by skipping every other comma in the query. Like so:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(a), <span class="number">2</span>):</span><br><span class="line">    s = <span class="string">&#x27;CREATE TABLE cards(id  INT  NOT NULL  PRIMARY KEY title  TEXT link  TEXT )&#x27;</span></span><br><span class="line">    s1 = s.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>
<p>The idea was to insert a command every two iterations of the loop, to coincide with the end of the attribute definitions, that would write a comma. But in the output, the commas came before the rest of the content.<br>I tried to add a comma to the values when they are inserted into to the list, but this only compounded the problems, not solved it.<br>But no luck, I never seemed to be on the commas I wanted to eliminate.<br>There was other stuff I tried or thought about. For instance, removing all the commas with ‘translate’ and then put only the ones I needed. Like so:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc12321cba&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.translate(&#123;<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>): <span class="literal">None</span>&#125;))</span><br></pre></td></tr></table></figure>
<p>But this would only take from a place where I had too many commas, to another, where I didn’t have enough.<br>At this point in time, I’m too tired and burnt out to think about this issue anymore. I’ll leave it alone for a few days and come back, hopefully, with another attitude.<br>As it was clear that I was getting nowhere in this direction, I thought to change the paradigm. What if instead of taking the loop values directly to the query, we would put them first in variables, and then from those well defined, clean variables, build a SQL expression.<br>This was closer to my original idea, (which, if ugly as hell, it’s still the one that works best, from all those that i came up with.), to declare all variables out loud, and go from there. As I am acutely aware of the horrible, horrible code that that approach begets, I tried to find a middle ground.<br>My idea was to create variables for each data item after leaving the loop, and create the query from them.<br>The problem that I faced, and that seems to me, as complex as the latter, is how to name variables that would be created automatically in a loop?<br>All that I read about this was how a terrible idea this is, and that we would be much better served if we created a dictionary.<br>Well, I have a dictionary, what I need is to free myself from it!<br>And here, again, slouches the old doubt, do I know enough about python dictionaries to say that this can’t be done with their methods?<br>Although how I don’t have an inkling how I would go about doing it, there’s always a nagging feeling in the back of my brain, telling me that this enormous problem is fruit of my ignorance, and that this could be solved with less coding and more studying. Which, even if true, would turn this endeavor into a massive chore. I have a lot of difficulties concentrating in a task where I’m not actively involved. To sit and absorb, doesn’t come easy to me. And yes, I had a lovely time at school, as you might imagine.<br>But I tried not be dissuaded by voices that, however well-meaning and informed, were explaining a problem that I didn’t fully understand and, most important, didn’t address my most urgent concern; how to solve MY problem.<br>So I tried to build the variables by globals():  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    <span class="built_in">globals</span>()[<span class="string">&#x27;key_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(key)] = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>but find it too cumbersome to be of any real value. I tried also to build them through exec and in this particular instance, couldn’t get it to work.<br>I’m keenly aware as I write these words that, these difficulties, may not be intrinsic to the problem, but fruit of  my own stupidity and ignorance.<br>Which makes me second guess myself even more. What, if you knew me, would know that is a lot.<br>I’m mainly writing these words in the hope that this is seen by someone that can help, or just say Hi!, but also in an effort to, through writing, get a clearer<br>understanding of the problem. Most of the time I navigate in a hazy dark soup of half-arsed intuitions and scraps of things I read online, and it feels like this all process needs more clarity and definition.<br>Hence this blog. And these words of mine; to you.</p>
</div></div><div class="footer"><div class="footer-copyright">Theme By <a target="_blank" rel="noopener" href="https://github.com/shinux/hexo-theme-adoubi">Adoubi</a> , Powered By Hexo.</div></div></body></html>